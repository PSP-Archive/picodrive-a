
/****************************************/
/*										*/
/* CZ80 (Z80 cpu emulator) version 0.9	*/
/* C Z80 emulator version 0.91			*/

/* Compiled with Dev-C++				*/
/* CZ80 include file					*/
/* CZ80 macro file						*/
/* CZ80 exec include source file		*/
/* CZ80 opcode include source file		*/

/* (C)2004-2005 Stephane Dallongeville	*/
/*										*/
/****************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "..\shared.h"
//#include "z80.h"

//extern unsigned char z80_readmem16(unsigned int address );
//extern void z80_writemem16(unsigned int address, unsigned char data );


#define VERBOSE 0
#if VERBOSE
#define LOG(x)	logerror x
#else
#define LOG(x)
#endif
#undef VERBOSE


/*************************************/
/* Z80 core Structures & definitions */
/*************************************/

//#define CZ80_FETCH_BITS 		4	// [4-12]	default = 8
//#define CZ80_FETCH_SFT			(16 - CZ80_FETCH_BITS)
//#define CZ80_FETCH_BANK 		(1 << CZ80_FETCH_BITS)

//#define CZ80_LIT TLE_ENDIAN	   1
//#define CZ80_USE_JUMPTABLE		1
#undef CZ80_USE_JUMPTABLE
//#define CZ80_USE_WO RD_HANDLER   0
#define CZ80_DEBUG				0



typedef union
{
	struct { UINT8 L,H; } B;
	UINT16 W;
} union16;

typedef struct
{
	union16 BC; 		// 32 bytes aligned
	union16 DE;
	union16 HL;
	union16 AF;

	union16 IX;
	union16 IY;
	union16 SP;
	UINT32 	PC;

	union16 BC2;
	union16 DE2;
	union16 HL2;
	union16 AF2;

	union16 R;
	union16 IFF;

	UINT8 I;
	UINT8 IM;
	UINT8 IRQVector;
	UINT8 IRQLine;
	UINT8 NMIState;
	UINT8 afterEI;
	UINT8 Halted;
	UINT8 filler;

//	UINT32 BasePC;

	int ICount;
	int InitialICount;
	int ExtraCycles;

//	UINT32 (*Read_Byte)(UINT32 adr);
//	void (*Write_Byte)(UINT32 adr, UINT32 data);
//#if CZ80_USE_WO RD_HANDLER
//	UINT32 (*Read_Word)(UINT32 adr);
//	void (*Write_Word)(UINT32 adr, UINT32 data);
//#endif

//	UINT32 (*IN_Port)(UINT32 port);
//	void (*OUT_Port)(UINT32 port, UINT32 value);

///	int (*irq_callback)(int line);
///	void (*RETI_Callback)(void);

//	UINT8 *Fetch[CZ80_FETCH_BANK];
} Z80_Regs;



#define CF	0x01
#define NF	0x02
#define PF	0x04
#define VF	PF
#define XF	0x08
#define HF	0x10
#define YF	0x20
#define ZF	0x40
#define SF	0x80

#define zR8(A)			(*pzR8[A])
#define zR16(A) 		(pzR16[A]->W)

#define pzAF			&(Z80.AF)
#define zAF 			Z80.AF.W
#define zlAF			Z80.AF.B.L
#define zhAF			Z80.AF.B.H
#define zA				zhAF
#define zF				zlAF

#define pzBC			&(Z80.BC)
#define zBC 			Z80.BC.W
#define zlBC			Z80.BC.B.L
#define zhBC			Z80.BC.B.H
#define zB				zhBC
#define zC				zlBC

#define pzDE			&(Z80.DE)
#define zDE 			Z80.DE.W
#define zlDE			Z80.DE.B.L
#define zhDE			Z80.DE.B.H
#define zD				zhDE
#define zE				zlDE

#define pzHL			&(Z80.HL)
#define zHL 			Z80.HL.W
#define zlHL			Z80.HL.B.L
#define zhHL			Z80.HL.B.H
#define zH				zhHL
#define zL				zlHL

#define zAF2			Z80.AF2.W
#define zlAF2			Z80.AF2.B.L
#define zhAF2			Z80.AF2.B.H
#define zA2 			zhAF2
#define zF2 			zlAF2

#define zBC2			Z80.BC2.W
#define zDE2			Z80.DE2.W
#define zHL2			Z80.HL2.W

#define pzIX			&(Z80.IX)
#define zIX 			Z80.IX.W
#define zlIX			Z80.IX.B.L
#define zhIX			Z80.IX.B.H

#define pzIY			&(Z80.IY)
#define zIY 			Z80.IY.W
#define zlIY			Z80.IY.B.L
#define zhIY			Z80.IY.B.H

#define pzSP			&(Z80.SP)
#define zSP 			Z80.SP.W
#define zlSP			Z80.SP.B.L
#define zhSP			Z80.SP.B.H

#define zRealPC			(zPC - zBase)
//#define zPC 			Z80.PC
//efine zBase			zBase
static unsigned char *zBase;//z80ram base
static unsigned char *zPC;//z80pc

#define zI				Z80.I
#define zIM 			Z80.IM

//#define zwR 			Z80.R.W
//#define zR1 			Z80.R.B.L
//#define zR2 			Z80.R.B.H
//#define zR				zR1

#define zIFF			Z80.IFF.W
#define zIFF1			Z80.IFF.B.L
#define zIFF2			Z80.IFF.B.H


#define CZ80_SF 		(1 << 7)
#define CZ80_ZF 		(1 << 6)
#define CZ80_YF 		(1 << 5)
#define CZ80_HF 		(1 << 4)
#define CZ80_XF 		(1 << 3)
#define CZ80_PF 		(1 << 2)
#define CZ80_VF 		(1 << 2)
#define CZ80_NF 		(1 << 1)
#define CZ80_CF 		(1 << 0)

//#define CZ80_IFF_SFT	CZ80_PF_SFT
#define CZ80_IFF_SFT	2
#define CZ80_IFF		CZ80_PF


//////////


//#if MAME_Z80
//extern int z80_ICount;
//#else
//#include "cz80.h"
#define z80_ICount  CZ80.ICount
//#endif


/*************************/
/* Publics Z80 variables */
/*************************/



// include macro file
//////////////////////

#ifdef CZ80_USE_JUMPTABLE
#define _SSOP(A,B)	A##B
#define OP(A)		_SSOP(OP, A)
#define OPCB(A) 	_SSOP(OPCB, A)
#define OPED(A) 	_SSOP(OPED, A)
#define OPXY(A) 	_SSOP(OPXY, A)
#define OPXYCB(A)	_SSOP(OPXYCB, A)
#else
#define OP(A)		case A
#define OPCB(A) 	case A
#define OPED(A) 	case A
#define OPXY(A) 	case A
#define OPXYCB(A)	case A
#endif

#define GET_BYTE		(*(UINT8*)zPC)

#define GET_BYTE_S		(*(INT8*)zPC)

//#define CZ80_LIT TLE_ENDIAN
//#if CZ80_LIT TLE_ENDIAN
#define GET_WORD	 ((*(UINT8*)(zPC  )) | ((*(UINT8*)(zPC+1)) << 8))
//#else
//#define GET_WORD	 ((*(UINT8*)(zPC+1)) | ((*(UINT8*)(zPC  )) << 8))
//#endif

#define FETCH_BYTE		(*(UINT8 *)zPC++)
#define FETCH_BYTE_S	(*(INT8 *)zPC++)
#define FETCH_WORD(A)	{ A = GET_WORD; zPC += 2; }

#define NEXT			{ Z80.ICount -= cc[Opcode]; goto Cz80_Exec; }
#define NEXT_EX 		{ Z80.ICount -= cc[Opcode] + cc_ex[Opcode]; goto Cz80_Exec; }

#define SET_PC(A)				\
	/*zBase = (UINT32) Z80.Fetch[(A) >> CZ80_FETCH_SFT];*/	\
	zPC = (A) + zBase;

#define READ_BYTE(A, D) 	D = /*Z80.Read_Byte*/z80_readmem16(A);

//#if CZ80_USE_WO RD_HANDLER
//#define RM16(A, D)	D = Z80.Read_Word(A);
//#elif CZ80_LIT TLE_ENDIAN
#define RM16(A, D) 	D = /*Z80.Read_Byte*/z80_readmem16(A) | (/*Z80.Read_Byte*/z80_readmem16((A) + 1) << 8);
//#else
//#define RM16(A, D)	D = (/*Z80.Read_Byte*/z80_readmem16(A) << 8) | /*Z80.Read_Byte*/z80_readmem16((A) + 1);
//#endif

#define READSX_BYTE(A, D)	D = (INT32)(INT8)/*Z80.Read_Byte*/z80_readmem16(A);

#define WRITE_BYTE(A, D)	/*Z80.Write_Byte*/z80_writemem16(A, D);

//#if CZ80_USE_WO RD_HANDLER
//#define WM16(A, D)
//	  Z80.Write_Word(A, D);
//#elif CZ80_LIT TLE_ENDIAN
#define WM16(A, D)				\
	/*Z80.Write_Byte*/z80_writemem16(A, D);			  \
	/*Z80.Write_Byte*/z80_writemem16((A) + 1, (D) >> 8);
//#else
//#define WM16(A, D)
//	  /*Z80.Write_Byte*/z80_writemem16(A, D);
//	  /*Z80.Write_Byte*/z80_writemem16((A) + 1, (D) >> 8);
//#endif

#define PUSH_16(A)			\
	zSP -= 2;				\
	WM16(zSP, A);

#define POP_16(A)			\
	RM16(zSP, A)		\
	zSP += 2;

//#define IN(A, D)		D = Z80.IN_Port(A);
#define IN(A, D)		D = 0xff;
//#define OUT(A, D) 	Z80.OUT_Port(A, D);
#define OUT(A, D)		;



// shared global variable
//////////////////////////


static Z80_Regs Z80 __attribute__((aligned(64))) ;

static UINT8 *pzR8[8];
static union16 *pzR16[4];

static UINT32 PC, EA;


static UINT8 SZ[256] __attribute__((aligned(64))) ; 	/* zero and sign flags */
static UINT8 SZ_BIT[256];	/* zero, sign and parity/overflow (=zero) flags for BIT opcode */
static UINT8 SZP[256];		/* zero, sign and parity flags */
static UINT8 SZHV_inc[256]; /* zero, sign, half carry and overflow flags INC r8 */
static UINT8 SZHV_dec[256]; /* zero, sign, half carry and overflow flags DEC r8 */


static const UINT8 cc_op[0x100] = {
	4,10, 7, 6, 4, 4, 7, 4, 4,11, 7, 6, 4, 4, 7, 4,
	8,10, 7, 6, 4, 4, 7, 4,12,11, 7, 6, 4, 4, 7, 4,
	7,10,16, 6, 4, 4, 7, 4, 7,11,16, 6, 4, 4, 7, 4,
	7,10,13, 6,11,11,10, 4, 7,11,13, 6, 4, 4, 7, 4,
	4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,
	4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,
	4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,
	7, 7, 7, 7, 7, 7, 4, 7, 4, 4, 4, 4, 4, 4, 7, 4,
	4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,
	4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,
	4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,
	4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4,
	5,10,10,10,10,11, 7,11, 5,10,10, 0,10,17, 7,11,
	5,10,10,11,10,11, 7,11, 5, 4,10,11,10, 0, 7,11,
	5,10,10,19,10,11, 7,11, 5, 4,10, 4,10, 0, 7,11,
	5,10,10, 4,10,11, 7,11, 5, 6,10, 4,10, 0, 7,11};

static const UINT8 cc_cb[0x100] = {
	8, 8, 8, 8, 8, 8,15, 8, 8, 8, 8, 8, 8, 8,15, 8,
	8, 8, 8, 8, 8, 8,15, 8, 8, 8, 8, 8, 8, 8,15, 8,
	8, 8, 8, 8, 8, 8,15, 8, 8, 8, 8, 8, 8, 8,15, 8,
	8, 8, 8, 8, 8, 8,15, 8, 8, 8, 8, 8, 8, 8,15, 8,
	8, 8, 8, 8, 8, 8,12, 8, 8, 8, 8, 8, 8, 8,12, 8,
	8, 8, 8, 8, 8, 8,12, 8, 8, 8, 8, 8, 8, 8,12, 8,
	8, 8, 8, 8, 8, 8,12, 8, 8, 8, 8, 8, 8, 8,12, 8,
	8, 8, 8, 8, 8, 8,12, 8, 8, 8, 8, 8, 8, 8,12, 8,
	8, 8, 8, 8, 8, 8,15, 8, 8, 8, 8, 8, 8, 8,15, 8,
	8, 8, 8, 8, 8, 8,15, 8, 8, 8, 8, 8, 8, 8,15, 8,
	8, 8, 8, 8, 8, 8,15, 8, 8, 8, 8, 8, 8, 8,15, 8,
	8, 8, 8, 8, 8, 8,15, 8, 8, 8, 8, 8, 8, 8,15, 8,
	8, 8, 8, 8, 8, 8,15, 8, 8, 8, 8, 8, 8, 8,15, 8,
	8, 8, 8, 8, 8, 8,15, 8, 8, 8, 8, 8, 8, 8,15, 8,
	8, 8, 8, 8, 8, 8,15, 8, 8, 8, 8, 8, 8, 8,15, 8,
	8, 8, 8, 8, 8, 8,15, 8, 8, 8, 8, 8, 8, 8,15, 8};

static const UINT8 cc_ed[0x100] = {
	 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	12,12,15,20, 8,14, 8, 9,12,12,15,20, 8,14, 8, 9,
	12,12,15,20, 8,14, 8, 9,12,12,15,20, 8,14, 8, 9,
	12,12,15,20, 8,14, 8,18,12,12,15,20, 8,14, 8,18,
	12,12,15,20, 8,14, 8, 8,12,12,15,20, 8,14, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	16,16,16,16, 8, 8, 8, 8,16,16,16,16, 8, 8, 8, 8,
	16,16,16,16, 8, 8, 8, 8,16,16,16,16, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8};

static const UINT8 cc_xy[0x100] = {
	 4, 4, 4, 4, 4, 4, 4, 4, 4,15, 4, 4, 4, 4, 4, 4,
	 4, 4, 4, 4, 4, 4, 4, 4, 4,15, 4, 4, 4, 4, 4, 4,
	 4,14,20,10, 9, 9, 9, 4, 4,15,20,10, 9, 9, 9, 4,
	 4, 4, 4, 4,23,23,19, 4, 4,15, 4, 4, 4, 4, 4, 4,
	 4, 4, 4, 4, 9, 9,19, 4, 4, 4, 4, 4, 9, 9,19, 4,
	 4, 4, 4, 4, 9, 9,19, 4, 4, 4, 4, 4, 9, 9,19, 4,
	 9, 9, 9, 9, 9, 9,19, 9, 9, 9, 9, 9, 9, 9,19, 9,
	19,19,19,19,19,19, 4,19, 4, 4, 4, 4, 9, 9,19, 4,
	 4, 4, 4, 4, 9, 9,19, 4, 4, 4, 4, 4, 9, 9,19, 4,
	 4, 4, 4, 4, 9, 9,19, 4, 4, 4, 4, 4, 9, 9,19, 4,
	 4, 4, 4, 4, 9, 9,19, 4, 4, 4, 4, 4, 9, 9,19, 4,
	 4, 4, 4, 4, 9, 9,19, 4, 4, 4, 4, 4, 9, 9,19, 4,
	 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4,
	 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
	 4,14, 4,23, 4,15, 4, 4, 4, 8, 4, 4, 4, 4, 4, 4,
	 4, 4, 4, 4, 4, 4, 4, 4, 4,10, 4, 4, 4, 4, 4, 4};

static const UINT8 cc_xycb[0x100] = {
	23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
	23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
	23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
	23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
	20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,
	20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,
	20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,
	20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,
	23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
	23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
	23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
	23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
	23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
	23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
	23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
	23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23};

/* extra cycles if jr/jp/call taken and 'interrupt latency' on rst 0-7 */
static const UINT8 cc_ex[0x100] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* DJNZ */
	5, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, /* JR NZ/JR Z */
	5, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, /* JR NC/JR C */
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	5, 5, 5, 5, 0, 0, 0, 0, 5, 5, 5, 5, 0, 0, 0, 0, /* LDIR/CPIR/INIR/OTIR LDDR/CPDR/INDR/OTDR */
	6, 0, 0, 0, 7, 0, 0, 2, 6, 0, 0, 0, 7, 0, 0, 2,
	6, 0, 0, 0, 7, 0, 0, 2, 6, 0, 0, 0, 7, 0, 0, 2,
	6, 0, 0, 0, 7, 0, 0, 2, 6, 0, 0, 0, 7, 0, 0, 2,
	6, 0, 0, 0, 7, 0, 0, 2, 6, 0, 0, 0, 7, 0, 0, 2};






/////////////////////////////////
//#ifndef CZ80_MACRO_H
//#define CZ80_MACRO_H

extern void z80_set_irq0(void);
/***************************************************************
 * Check IRQ
 ***************************************************************/

#define CHECK_INT													\
	if(zIFF1) {												\
		Z80.Halted = 0;											\
		zIFF1 = zIFF2 = 0;											\
	/*	Z80.IRQVector = Z80.irq_callback(0);*/				\
		z80_set_irq0();\
		z80_set_irq_line(0, CLEAR_LINE);\
		Z80.IRQVector = 0xff;\
																	\
		if(zIM == 2) {												\
			PUSH_16(zRealPC) 									\
			Z80.IRQVector = (Z80.IRQVector & 0xff) | (zI << 8);	\
			RM16(Z80.IRQVector, PC)							\
			SET_PC(PC)												\
			Z80.ExtraCycles += 17; 								\
		}															\
		else if(zIM == 1) {												\
			PUSH_16(zRealPC) 									\
			SET_PC(0x38)											\
			Z80.ExtraCycles += 13; 								\
		}															\
		else {												\
			LOG(("Z80 IM0 $%04x\n", Z80.IRQVector));				\
			switch (Z80.IRQVector & 0xff0000)						\
			{														\
			case 0xcd0000:	/* call */								\
				PUSH_16(zRealPC) 								\
				PC = Z80.IRQVector & 0xffff;						\
				SET_PC(PC)											\
				Z80.ExtraCycles += 19; 							\
				break;												\
																	\
			case 0xc30000:	/* jump */								\
				PC = Z80.IRQVector & 0xffff;						\
				SET_PC(PC)											\
				Z80.ExtraCycles += 12; 							\
				break;												\
																	\
			default:												\
				PUSH_16(zRealPC) 								\
				PC = Z80.IRQVector & 0x38; 						\
				SET_PC(PC)											\
				Z80.ExtraCycles += 13; 							\
				break;												\
			}														\
		}															\
	}



/***************************************************************
 * Main OP code
 ***************************************************************/

/***************************************************************
 * POP
 ***************************************************************/
#define POP(r16) POP_16(r16)

/***************************************************************
 * PUSH
 ***************************************************************/
#define PUSH(r16) PUSH_16(r16)

/***************************************************************
 * JP
 ***************************************************************/
#define JP {												\
	PC = GET_WORD;												\
	SET_PC(PC)													\
}

/***************************************************************
 * JP_COND
 ***************************************************************/
#define JP_COND(cond)											\
	if(cond) {												\
		JP														\
		NEXT_EX 												\
	}															\
	else zPC += 2;

/***************************************************************
 * JR
 ***************************************************************/
#define JR {												\
	PC = zPC + FETCH_BYTE_S;									\
	SET_PC(PC)													\
}

/***************************************************************
 * JR_COND
 ***************************************************************/
#define JR_COND(cond)											\
	if(cond) {												\
		JR														\
		NEXT_EX 												\
	}															\
	else zPC++;

/***************************************************************
 * CALL
 ***************************************************************/
#define CALL {												\
	FETCH_WORD(PC); 											\
	PUSH_16(zRealPC);											\
	SET_PC(PC); 												\
}

/***************************************************************
 * CALL_COND
 ***************************************************************/
#define CALL_COND(cond) 										\
	if(cond) {												\
		CALL													\
		NEXT_EX 												\
	}															\
	else zPC += 2;

/***************************************************************
 * RET
 ***************************************************************/
#define _RET {												\
	POP_16(PC); 												\
	SET_PC(PC); 												\
}

/***************************************************************
 * RET_COND
 ***************************************************************/
#define RET_COND(cond)											\
	if(cond) {												\
		RET 													\
		NEXT_EX 												\
	}

/***************************************************************
 * RST
 ***************************************************************/
#define RST(addr) {												\
	PUSH_16(zRealPC) 										\
	SET_PC(addr)												\
}

/***************************************************************
 * RLCA
 ***************************************************************/
#define RLCA													\
	zA = (zA << 1) | (zA >> 7); 								\
	zF = (zF & (SF | ZF | PF)) | (zA & (YF | XF | CF));

/***************************************************************
 * RRCA
 ***************************************************************/
#define RRCA													\
	zF = (zF & (SF | ZF | PF)) | (zA & CF); 					\
	zA = (zA >> 1) | (zA << 7); 								\
	zF |= (zA & (YF | XF));

/***************************************************************
 * RLA
 ***************************************************************/
#define RLA {												\
	UINT8 r = (zA << 1) | (zF & CF);								\
	UINT8 c = (zA & 0x80) ? CF : 0; 							\
	zF = (zF & (SF | ZF | PF)) | c | (r & (YF | XF));			\
	zA = r; 													\
}

/***************************************************************
 * RRA
 ***************************************************************/
#define RRA {												\
	UINT8 r = (zA >> 1) | (zF << 7);								\
	UINT8 c = (zA & 0x01) ? CF : 0; 							\
	zF = (zF & (SF | ZF | PF)) | c | (r & (YF | XF));			\
	zA = r; 													\
}

/***************************************************************
 * EX	r16,r16
 ***************************************************************/
#define EX(a, b) {												\
	val = a; a = b; b = val;									\
}

/***************************************************************
 * EX	(SP),r16
 ***************************************************************/
#define EXSP(r16) {												\
	val = r16;													\
	RM16(zSP, r16) 										\
	WM16(zSP, val)										\
}

/***************************************************************
 * INC	n
 ***************************************************************/
#define INC(n) {												\
	n = (n + 1) & 0xff; 										\
	zF = (zF & CF) | SZHV_inc[n];								\
}

/***************************************************************
 * DEC	n
 ***************************************************************/
#define DEC(n) {												\
	n = (n - 1) & 0xff; 										\
	zF = (zF & CF) | SZHV_inc[n];								\
}

/***************************************************************
 * DAA
 ***************************************************************/
#define DAA {												\
	UINT8 cf, nf, hf, lo, hi, diff; 							\
	cf = zF & CF;												\
	nf = zF & NF;												\
	hf = zF & HF;												\
	lo = zA & 15;												\
	hi = zA / 16;												\
																\
	if(cf) {												\
		diff = (lo <= 9 && !hf) ? 0x60 : 0x66;					\
	}															\
	else {												\
		if(lo >= 10) {												\
			diff = hi <= 8 ? 0x06 : 0x66;						\
		}														\
		else {												\
			if(hi >= 10) {												\
				diff = hf ? 0x66 : 0x60;						\
			}													\
			else {												\
				diff = hf ? 0x06 : 0x00;						\
			}													\
		}														\
	}															\
	if(nf) zA -= diff; 										\
	else zA += diff;											\
																\
	zF = SZP[zA] | (zF & NF);									\
	if(cf || (lo <= 9 ? hi >= 10 : hi >= 9)) zF |= CF; 		\
	if(nf ? hf && lo <= 5 : lo >= 10)	zF |= HF;				\
}

/***************************************************************
 * CPL
 ***************************************************************/
#define CPL {												\
	zA ^= 0xff; 												\
	zF = (zF & (SF | ZF | PF | CF))| HF | NF | (zA & (YF | XF));\
}

/***************************************************************
 * SCF
 ***************************************************************/
#define SCF {												\
	zF = (zF & (SF | ZF | PF)) | CF | (zA & (YF | XF)); 		\
}

/***************************************************************
 * CCF
 ***************************************************************/
#define CCF {												\
	zF = ((zF & (SF | ZF | PF | CF)) | ((zF & CF) << 4) 		\
		| (zA & (YF | XF))) ^ CF;								\
}

/***************************************************************
 * AND	n
 ***************************************************************/
#define AND(n)													\
	zA &= n;													\
	zF = SZP[zA] | HF;

/***************************************************************
 * OR	n
 ***************************************************************/
#define OR(n)													\
	zA |= n;													\
	zF = SZP[zA];

/***************************************************************
 * XOR	n
 ***************************************************************/
#define XOR(n)													\
	zA ^= n;													\
	zF = SZP[zA];

/***************************************************************
 * ADD	A,n
 ***************************************************************/
#define ADD(n) {												\
	UINT32 v = n;													\
	UINT32 r = zA + v;												\
	zF = SZ[(UINT8)r] | ((r >> 8) & CF) |							\
		((zA ^ r ^ v) & HF) |									\
		(((v ^ zA ^ 0x80) & (v ^ r) & 0x80) >> 5);				\
	zA = (UINT8)r;													\
}

/***************************************************************
 * ADC	A,n
 ***************************************************************/
#define ADC(n) {												\
	UINT32 v = n;													\
	UINT32 r = zA + v + (zF & CF);									\
	zF = SZ[r & 0xff] | ((r >> 8) & CF) |						\
		((zA ^ r ^ v) & HF) |									\
		(((v ^ zA ^ 0x80) & (v ^ r) & 0x80) >> 5);				\
	zA = r; 													\
}

/***************************************************************
 * SUB	n
 ***************************************************************/
#define SUB(n) {												\
	UINT32 v = n;													\
	UINT32 r = zA - v;												\
	zF = SZ[r & 0xff] | ((r >> 8) & CF) | NF |					\
		((zA ^ r ^ v) & HF) |									\
		(((v ^ zA) & (zA ^ r) & 0x80) >> 5);					\
	zA = r; 													\
}

/***************************************************************
 * SBC	A,n
 ***************************************************************/
#define SBC(n) {												\
	UINT32 v = n;													\
	UINT32 r = zA - v - (zF & CF);									\
	zF = SZ[r & 0xff] | ((r >> 8) & CF) | NF |					\
		((zA ^ r ^ v) & HF) |									\
		(((v ^ zA) & (zA ^ r) & 0x80) >> 5);					\
	zA = r; 													\
}

/***************************************************************
 * CP	n
 ***************************************************************/
#define CP(n) {												\
	UINT32 v = n;													\
	UINT32 r = zA - v;												\
	zF = (SZ[r & 0xff] & (SF | ZF)) |							\
		(v & (YF | XF)) | ((r >> 8) & CF) | NF |				\
		((zA ^ r ^ v) & HF) |									\
		((((v ^ zA) & (zA ^ r)) >> 5) & VF);					\
}

/***************************************************************
 * ADD16
 ***************************************************************/
#define ADD16(dst, src) {												\
	UINT32 r = dst + src;											\
	zF = (zF & (SF | ZF | VF)) |								\
		(((dst ^ r ^ src) >> 8) & HF) | 						\
		((r >> 16) & CF) | ((r >> 8) & (YF | XF));				\
	dst = (UINT16)r;												\
}

/***************************************************************
 * EI
 ***************************************************************/
#define EI {												\
	Z80.ICount -= cc[Opcode];									\
	if(zIFF1 == 0) 											\
	{															\
		zIFF1 = zIFF2 = 1;										\
		/*zR++;*/													\
		while (GET_BYTE == 0xfb) {												\
		/*	LOG(("Z80 multiple EI opcodes at %04X\n", zRealPC));*/\
			Z80.ICount -= cc[Opcode];							\
			zPC++;												\
			/*zR++;*/												\
		}														\
		if(Z80.IRQLine) {												\
			Z80.afterEI = 1;									\
			Z80.ExtraCycles = Z80.ICount; 					\
			Z80.ICount = 1;									\
		}														\
	} else zIFF2 = 1;											\
}


/***************************************************************
 for CB prefix
 ***************************************************************/

/***************************************************************
 * RLC	r8
 ***************************************************************/
#define RLC(r) {												\
	UINT32 v = r;													\
	UINT32 c = (v & 0x80) ? CF : 0; 							\
	v = ((v << 1) | (v >> 7)) & 0xff;							\
	zF = SZP[v] | c;											\
	r = v;														\
}

/***************************************************************
 * RRC	r8
 ***************************************************************/
#define RRC(r) {												\
	UINT32 v = r;													\
	UINT32 c = (v & 0x01) ? CF : 0; 							\
	v = ((v >> 1) | (v << 7)) & 0xff;							\
	zF = SZP[v] | c;											\
	r = v;														\
}

/***************************************************************
 * RL	r8
 ***************************************************************/
#define RL(r) {												\
	UINT32 v = r;													\
	UINT32 c = (v & 0x80) ? CF : 0; 							\
	v = ((v << 1) | (zF & CF)) & 0xff;							\
	zF = SZP[v] | c;											\
	r = v;														\
}

/***************************************************************
 * RR	r8
 ***************************************************************/
#define RR(r) {												\
	UINT32 v = r;													\
	UINT32 c = (v & 0x01) ? CF : 0; 							\
	v = ((v >> 1) | (zF << 7)) & 0xff;							\
	zF = SZP[v] | c;											\
	r = v;														\
}

/***************************************************************
 * SLA	r8
 ***************************************************************/
#define SLA(r) {												\
	UINT32 v = r;													\
	UINT32 c = (v & 0x80) ? CF : 0; 							\
	v = (v << 1) & 0xff;										\
	zF = SZP[v] | c;											\
	r = v;														\
}

/***************************************************************
 * SRA	r8
 ***************************************************************/
#define SRA(r) {												\
	UINT32 v = r;													\
	UINT32 c = (v & 0x01) ? CF : 0; 							\
	v = ((v >> 1) | (v & 0x80)) & 0xff; 						\
	zF = SZP[v] | c;											\
	r = v;														\
}

/***************************************************************
 * SLL	r8
 ***************************************************************/
#define SLL(r) {												\
	UINT32 v = r;													\
	UINT32 c = (v & 0x80) ? CF : 0; 							\
	v = ((v << 1) | 0x01) & 0xff;								\
	zF = SZP[v] | c;											\
	r = v;														\
}

/***************************************************************
 * SRL	r8
 ***************************************************************/
#define SRL(r) {												\
	UINT32 v = r;													\
	UINT32 c = (v & 0x01) ? CF : 0; 							\
	v = (v >> 1) & 0xff;										\
	zF = SZP[v] | c;											\
	r = v;														\
}

/***************************************************************
 * BIT	bit,r8
 ***************************************************************/
#undef BIT
#define BIT(reg, bit) {												\
	zF = (zF & CF) | HF | SZ_BIT[reg & (1 << bit)]; 			\
}

/***************************************************************
 * BIT	bit,(IX/Y+o)
 ***************************************************************/

#define BIT_XY(reg, bit) {												\
	zF = (zF & CF) | HF |										\
		 (SZ_BIT[reg & (1<<bit)] & ~(YF | XF)) |				\
		 ((EA >> 8) & (YF | XF));								\
}

/***************************************************************
 * RES	bit,r8
 ***************************************************************/
#define RES(value, bit) {												\
	value &= ~(1 << bit);										\
}

/***************************************************************
 * SET	bit,r8
 ***************************************************************/
#define SET(value, bit) {												\
	value |= (1 << bit);										\
}



/***************************************************************
 for ED prefix
 ***************************************************************/

/***************************************************************
 * Iiiegal (ED prefix)
 ***************************************************************/
#define illegal_ed {												\
	LOG(("Z80 ill. opcode $ed $%02x\n", Opcode));				\
}

/***************************************************************
 * LD	R,A
 ***************************************************************/
#define LD_R_A {												\
	/*zR = zA;*/												\
	/*zR2 = zA & 0x80;*/			/* keep bit 7 of R */		\
}

/***************************************************************
 * LD	A,R
 ***************************************************************/
#define LD_A_R {												\
	zA = (zA+7)&0xff;/*(zR & 0x7f) | zR2;*/ 					\
	zF = (zF & CF) | SZ[zA] | ( zIFF2 << 2 );					\
}

/***************************************************************
 * LD	I,A
 ***************************************************************/
#define LD_I_A {												\
	zI = zA;													\
}

/***************************************************************
 * LD	A,I
 ***************************************************************/
#define LD_A_I {												\
	zA = zI;													\
	zF = (zF & CF) | SZ[zA] | (zIFF2 << 2); 					\
}



/***************************************************************
 * RRD
 ***************************************************************/
#define RRD {												\
	UINT8 n;													\
	READ_BYTE(zHL, n)											\
	WRITE_BYTE(zHL, (n >> 4) | (zA << 4))						\
	zA = (zA & 0xf0) | (n & 0x0f);								\
	zF = (zF & CF) | SZP[zA];									\
}

/***************************************************************
 * RLD
 ***************************************************************/
#define RLD {												\
	UINT8 n;													\
	READ_BYTE(zHL, n)											\
	WRITE_BYTE(zHL, (n << 4) | (zA & 0x0f)) 					\
	zA = (zA & 0xf0) | (n >> 4);								\
	zF = (zF & CF) | SZP[zA];									\
}

/***************************************************************
 * NEG
 ***************************************************************/
#define NEG {												\
	UINT32 v = zA;													\
	UINT32 r = 0 - v;												\
	zA = 0; 													\
	zF = SZ[r & 0xff] | ((r >> 8) & CF) | NF |					\
		((zA ^ r ^ v) & HF) |									\
		(((v ^ zA) & (zA ^ r) & 0x80) >> 5);					\
	zA = r; 													\
}

/***************************************************************
 * ADC	r16,r16
 ***************************************************************/
#define ADC16(r16) {												\
	UINT32 r = zHL + r16 + (zF & CF);								\
	zF = (((zHL ^ r ^ r16) >> 8) & HF) |						\
		((r >> 16) & CF) |										\
		((r >> 8) & (SF | YF | XF)) |							\
		((r & 0xffff) ? 0 : ZF) |								\
		(((r16 ^ zHL ^ 0x8000) & (r16 ^ r) & 0x8000) >> 13);	\
	zHL = (UINT16)r;												\
}

/***************************************************************
 * SBC	r16,r16
 ***************************************************************/
#define SBC16(r16) {												\
	UINT32 r = zHL - r16 - (zF & CF);								\
	zF = (((zHL ^ r ^ r16) >> 8) & HF) | NF |					\
		((r >> 16) & CF) |										\
		((r >> 8) & (SF | YF | XF)) |							\
		((r & 0xffff) ? 0 : ZF) |								\
		(((r16 ^ zHL) & (zHL ^ r) & 0x8000) >> 13); 			\
	zHL = (UINT16)r;												\
}

/***************************************************************
 * RETN
 ***************************************************************/
#define RETN {												\
	LOG(("Z80 RETN IFF1:%d IFF2:%d\n", zIFF1, zIFF2));			\
	POP_16(PC); 												\
	SET_PC(PC); 												\
	if(zIFF1 == 0 && zIFF2 == 1) {												\
		zIFF1 = 1;												\
		if(Z80.IRQLine) {												\
			LOG(("Z80 RETN takes IRQ\n"));						\
			CHECK_INT											\
		}														\
	}															\
	else zIFF1 = zIFF2; 										\
}

/***************************************************************
 * RETI
 ***************************************************************/
#define RETI {												\
	/*if(Z80.RETI_Callback) Z80.RETI_Callback();*/				\
	POP_16(PC); 												\
	SET_PC(PC); 												\
/* according to http://www.msxnet.org/tech/z80-documented.pdf */\
/*	zIFF1 = zIFF2; */											\
}

/***************************************************************
 * LDI
 ***************************************************************/
#define LDI {												\
	UINT8 io;														\
	READ_BYTE(zHL, io)											\
	WRITE_BYTE(zDE, io) 										\
																\
	zF &= SF | ZF | CF; 										\
	if((zA + io) & 0x02) zF |= YF; 							\
	if((zA + io) & 0x08) zF |= XF; 							\
																\
	zHL++;														\
	zDE++;														\
	zBC--;														\
																\
	if(zBC) zF |= VF;											\
}

/***************************************************************
 * CPI
 ***************************************************************/
#define CPI {												\
	UINT8 v, r; 												\
																\
	READ_BYTE(zHL, v)											\
	r = zA - v; 												\
	zHL++;														\
	zBC--;														\
																\
	zF = (zF & CF) | (SZ[r] & ~(YF | XF)) | 					\
		 ((zA ^ v ^ r) & HF) | NF;								\
	if(zF & HF) r -= 1;										\
	if(r & 0x02) zF |= YF; 									\
	if(r & 0x08) zF |= XF; 									\
	if(zBC) zF |= VF;											\
}

/***************************************************************
 * INI
 ***************************************************************/
#define INI {												\
	UINT8 io;														\
	UINT32 t;														\
																\
	IN(zBC, io) 												\
	zB--;														\
	WRITE_BYTE(zHL, io) 										\
	zHL++;														\
																\
	zF = SZ[zB];												\
	t = ((UINT32)(zC - 1) & 0xff) + (UINT32)io; 					\
	if(io & SF) zF |= NF;										\
	if(t & 0x100) zF |= HF | CF;								\
	zF |= SZP[(UINT8)(t & 0x07) ^ zB] & PF; 					\
}

/***************************************************************
 * OUTI
 ***************************************************************/
#define OUTI {												\
	UINT8 io;														\
	UINT32 t;														\
																\
	READ_BYTE(zHL, io)											\
	zB--;														\
	OUT(zBC, io)												\
	zHL++;														\
																\
	zF = SZ[zB];												\
	t = (UINT32)zL + (UINT32)io;										\
	if(io & SF) zF |= NF;										\
	if(t & 0x100) zF |= HF | CF;								\
	zF |= SZP[(UINT8)(t & 0x07) ^ zB] & PF; 					\
}

/***************************************************************
 * LDD
 ***************************************************************/
#define LDD {												\
	UINT8 io;														\
																\
	READ_BYTE(zHL, io)											\
	WRITE_BYTE(zDE, io) 										\
																\
	zF &= SF | ZF | CF; 										\
	if((zA + io) & 0x02) zF |= YF; 							\
	if((zA + io) & 0x08) zF |= XF; 							\
																\
	zHL--;														\
	zDE--;														\
	zBC--;														\
																\
	if(zBC) zF |= VF;											\
}

/***************************************************************
 * CPD
 ***************************************************************/
#define CPD {												\
	UINT8 v, r; 												\
																\
	READ_BYTE(zHL, v)											\
	r = zA - v; 												\
	zHL--;														\
	zBC--;														\
																\
	zF = (zF & CF) | (SZ[r] & ~(YF | XF)) | 					\
		 ((zA ^ v ^ r) & HF) | NF;								\
	if(zF & HF) r -= 1;										\
	if(r & 0x02) zF |= YF; 									\
	if(r & 0x08) zF |= XF; 									\
	if(zBC) zF |= VF;											\
}

/***************************************************************
 * IND
 ***************************************************************/
#define IND {												\
	UINT8 io;														\
	UINT32 t;														\
																\
	IN(zBC, io) 												\
	zB--;														\
	WRITE_BYTE(zHL, io) 										\
	zHL--;														\
																\
	zF = SZ[zB];												\
	t = ((UINT32)(zC - 1) & 0xff) + (UINT32)io; 					\
	if(io & SF) zF |= NF;										\
	if(t & 0x100) zF |= HF | CF;								\
	zF |= SZP[(UINT8)(t & 0x07) ^ zB] & PF; 					\
}

/***************************************************************
 * OUTD
 ***************************************************************/
#define OUTD {												\
	UINT8 io;														\
	UINT32 t;														\
																\
	READ_BYTE(zHL, io)											\
	zB--;														\
	OUT(zBC, io)												\
	zHL--;														\
																\
	zF = SZ[zB];												\
	t = (UINT32)zL + (UINT32)io;										\
	if(io & SF) zF |= NF;										\
	if(t & 0x100) zF |= HF | CF;								\
	zF |= SZP[(UINT8)(t & 0x07) ^ zB] & PF; 					\
}

/***************************************************************
 * LDIR
 ***************************************************************/
#define LDIR {												\
	LDI 														\
	if(zBC) {												\
		zPC -= 2;												\
		NEXT_EX 												\
	}															\
}

/***************************************************************
 * CPIR
 ***************************************************************/
#define CPIR {												\
	CPI 														\
	if(zBC && !(zF & ZF)) {												\
		zPC -= 2;												\
		NEXT_EX 												\
	}															\
}

/***************************************************************
 * INIR
 ***************************************************************/
#define INIR {												\
	INI 														\
	if(zB) {												\
		zPC -= 2;												\
		NEXT_EX 												\
	}															\
}

/***************************************************************
 * OTIR
 ***************************************************************/
#define OTIR {												\
	OUTI														\
	if(zB) {												\
		zPC -= 2;												\
		NEXT_EX 												\
	}															\
}

/***************************************************************
 * LDDR
 ***************************************************************/
#define LDDR {												\
	LDD 														\
	if(zBC) {												\
		zPC -= 2;												\
		NEXT_EX 												\
	}															\
}

/***************************************************************
 * CPDR
 ***************************************************************/
#define CPDR {												\
	CPD 														\
	if(zBC && !(zF & ZF)) {												\
		zPC -= 2;												\
		NEXT_EX 												\
	}															\
}

/***************************************************************
 * INDR
 ***************************************************************/
#define INDR {												\
	IND 														\
	if(zB) {												\
		zPC -= 2;												\
		NEXT_EX 												\
	}															\
}

/***************************************************************
 * OTDR
 ***************************************************************/
#define OTDR {												\
	OUTD														\
	if(zB) {												\
		zPC -= 2;												\
		NEXT_EX 												\
	}															\
}



/***************************************************************
 for DD / FD prefix
 ***************************************************************/

/***************************************************************
 * Calculate the effective addrs EA of an opcode
 ***************************************************************/
#define EAX EA = zIX + FETCH_BYTE_S;
#define EAY EA = zIY + FETCH_BYTE_S;

/***************************************************************
 * Iiiegal (DD / FD prefix)
 ***************************************************************/
#define illegal_xy {												\
	LOG(("Z80 ill. opcode $02x $%02x\n", *(zPC - 1), Opcode));	\
}

//#endif /* CZ80_MACRO_H */








/****************************************************************************
 * Execute 'cycles' T-states. Return number of T-states really executed
 ****************************************************************************/
 void z80_debt_clk(short cycles){
	Z80.ExtraCycles+=cycles;
}

int z80_execute(short cycles)
//{
////	if(cpu_enable)
//		return Cz80_Exec( cycles);
////	else
////		return cycles;
//}
//int Cz80_Exec( int cycles)
{
#ifdef CZ80_USE_JUMPTABLE
#include "inc_jmp.c"
#endif

	UINT32 Opcode;
	UINT32 val;
	const UINT8 *cc;

	Z80.InitialICount = Z80.ICount = cycles - Z80.ExtraCycles;
	Z80.ExtraCycles = 0;
	Z80.afterEI = 0;

	if(Z80.Halted)
	{
		Z80.ICount &= 3;
		Z80.ICount -= 4;
		goto Cz80_Exec_Really_End;
	}

Cz80_Exec:
	if(Z80.ICount > 0)
	{
		union16 *data = pzHL;

		/*zR++;*/
		Opcode = FETCH_BYTE;
		cc = cc_op;
//		#include "cz80_op.c"


#ifdef CZ80_USE_JUMPTABLE
	goto *JumpTable[Opcode];
#else
//MAIN_OP:
switch (Opcode)
{
#endif

/*-----------------------------------------
 NOP
-----------------------------------------*/
	OP(0x00):	// NOP


/*-----------------------------------------
 LD r8 (same register)
-----------------------------------------*/

	OP(0x40):	// LD	B,B
	OP(0x49):	// LD	C,C
	OP(0x52):	// LD	D,D
	OP(0x5b):	// LD	E,E
	OP(0x64):	// LD	H,H
	OP(0x6d):	// LD	L,L
	OP(0x7f):	// LD	A,A
OP_NOP:
		NEXT


/*-----------------------------------------
 LD r8
-----------------------------------------*/

	OP(0x41):	// LD	B,C
	OP(0x42):	// LD	B,D
	OP(0x43):	// LD	B,E
	OP(0x44):	// LD	B,H
	OP(0x45):	// LD	B,L
	OP(0x47):	// LD	B,A

	OP(0x48):	// LD	C,B
	OP(0x4a):	// LD	C,D
	OP(0x4b):	// LD	C,E
	OP(0x4c):	// LD	C,H
	OP(0x4d):	// LD	C,L
	OP(0x4f):	// LD	C,A

	OP(0x50):	// LD	D,B
	OP(0x51):	// LD	D,C
	OP(0x53):	// LD	D,E
	OP(0x54):	// LD	D,H
	OP(0x55):	// LD	D,L
	OP(0x57):	// LD	D,A

	OP(0x58):	// LD	E,B
	OP(0x59):	// LD	E,C
	OP(0x5a):	// LD	E,D
	OP(0x5c):	// LD	E,H
	OP(0x5d):	// LD	E,L
	OP(0x5f):	// LD	E,A

	OP(0x60):	// LD	H,B
	OP(0x61):	// LD	H,C
	OP(0x62):	// LD	H,D
	OP(0x63):	// LD	H,E
	OP(0x65):	// LD	H,L
	OP(0x67):	// LD	H,A

	OP(0x68):	// LD	L,B
	OP(0x69):	// LD	L,C
	OP(0x6a):	// LD	L,D
	OP(0x6b):	// LD	L,E
	OP(0x6c):	// LD	L,H
	OP(0x6f):	// LD	L,A

	OP(0x78):	// LD	A,B
	OP(0x79):	// LD	A,C
	OP(0x7a):	// LD	A,D
	OP(0x7b):	// LD	A,E
	OP(0x7c):	// LD	A,H
	OP(0x7d):	// LD	A,L
OP_LD_R_R:
		zR8((Opcode >> 3) & 7) = zR8(Opcode & 7);
		NEXT

	OP(0x06):	// LD	B,#imm
	OP(0x0e):	// LD	C,#imm
	OP(0x16):	// LD	D,#imm
	OP(0x1e):	// LD	E,#imm
	OP(0x26):	// LD	H,#imm
	OP(0x2e):	// LD	L,#imm
	OP(0x3e):	// LD	A,#imm
OP_LD_R_imm:
		zR8(Opcode >> 3) = FETCH_BYTE;
		NEXT

	OP(0x46):	// LD	B,(HL)
	OP(0x4e):	// LD	C,(HL)
	OP(0x56):	// LD	D,(HL)
	OP(0x5e):	// LD	E,(HL)
	OP(0x66):	// LD	H,(HL)
	OP(0x6e):	// LD	L,(HL)
	OP(0x7e):	// LD	A,(HL)
//OP_LD_R_mHL:
		READ_BYTE(zHL, zR8((Opcode >> 3) & 7))
		NEXT

	OP(0x70):	// LD	(HL),B
	OP(0x71):	// LD	(HL),C
	OP(0x72):	// LD	(HL),D
	OP(0x73):	// LD	(HL),E
	OP(0x74):	// LD	(HL),H
	OP(0x75):	// LD	(HL),L
	OP(0x77):	// LD	(HL),A
//OP_LD_mHL_R:
		WRITE_BYTE(zHL, zR8(Opcode & 7))
		NEXT

	OP(0x36):	// LD (HL), #imm
//OP_LD_mHL_imm:
		WRITE_BYTE(zHL, FETCH_BYTE)
		NEXT

	OP(0x0a):	// LD	A,(BC)
OP_LOAD_A_mBC:
		EA = zBC;
		goto OP_LOAD_A_mxx;

	OP(0x1a):	// LD	A,(DE)
OP_LOAD_A_mDE:
		EA = zDE;

OP_LOAD_A_mxx:
		READ_BYTE(EA, zA)
		NEXT

	OP(0x3a):	// LD	A,(nn)
OP_LOAD_A_mNN:
		FETCH_WORD(EA)
		READ_BYTE(EA, zA)
		NEXT

	OP(0x02):	// LD	(BC),A
OP_LOAD_mBC_A:
		EA = zBC;
		goto OP_LOAD_mxx_A;

	OP(0x12):	// LD	(DE),A
OP_LOAD_mDE_A:
		EA = zDE;

OP_LOAD_mxx_A:
		WRITE_BYTE(EA, zA)
		NEXT

	OP(0x32):	// LD	(nn),A
OP_LOAD_mNN_A:
		FETCH_WORD(EA)
		WRITE_BYTE(EA, zA)
		NEXT


/*-----------------------------------------
 LD r16
-----------------------------------------*/

	OP(0x01):	// LD	BC,nn
	OP(0x11):	// LD	DE,nn
	OP(0x21):	// LD	HL,nn
OP_LOAD_RR_imm16:
		FETCH_WORD(zR16(Opcode >> 4))
		NEXT

	OP(0x31):	// LD	SP,nn
OP_LOAD_SP_imm16:
		FETCH_WORD(zSP)
		NEXT

	OP(0xf9):	// LD	SP,HL
OP_LD_SP_xx:
		zSP = data->W;
		NEXT

	OP(0x2a):	// LD	HL,(nn)
OP_LD_xx_mNN:
		FETCH_WORD(EA)
		RM16(EA, data->W)
		NEXT

	OP(0x22):	// LD	(nn),HL
OP_LD_mNN_xx:
		FETCH_WORD(EA)
		WM16(EA, data->W)
		NEXT


/*-----------------------------------------
 POP
-----------------------------------------*/

	OP(0xc1):	// POP	BC
	OP(0xd1):	// POP	DE
	OP(0xf1):	// POP	AF
OP_POP_RR:
		data = pzR16[(Opcode >> 4) & 3];

	OP(0xe1):	// POP	HL
OP_POP:
		POP_16(data->W)
		NEXT


/*-----------------------------------------
 PUSH
-----------------------------------------*/

	OP(0xc5):	// PUSH BC
	OP(0xd5):	// PUSH DE
	OP(0xf5):	// PUSH AF
OP_PUSH_RR:
		data = pzR16[(Opcode >> 4) & 3];

	OP(0xe5):	// PUSH HL
OP_PUSH:
		PUSH_16(data->W);
		NEXT


/*-----------------------------------------
 EX
-----------------------------------------*/

	OP(0x08):	// EX	AF,AF'
OP_EX_AF_AF2:
		EX(zAF, zAF2)
		NEXT

	OP(0xeb):	// EX	DE,HL
OP_EX_DE_HL:
		EX(zDE, zHL)
		NEXT

	OP(0xd9):	// EXX
OP_EXX:
		EX(zBC, zBC2)
		EX(zDE, zDE2)
		EX(zHL, zHL2)
		NEXT

	OP(0xe3):	// EX	HL,(SP)
OP_EX_xx_mSP:
		val = data->W;
		RM16(zSP, data->W)
		WM16(zSP, val)
		NEXT


/*-----------------------------------------
 INC r8
-----------------------------------------*/

	OP(0x04):	// INC	B
	OP(0x0c):	// INC	C
	OP(0x14):	// INC	D
	OP(0x1c):	// INC	E
	OP(0x24):	// INC	H
	OP(0x2c):	// INC	L
	OP(0x3c):	// INC	A
OP_INC_R:
		zR8(Opcode >> 3)++;
		zF = (zF & CF) | SZHV_inc[zR8(Opcode >> 3)];
		NEXT

OP_INC_mIx:
		EA = data->W + FETCH_BYTE_S;
		goto OP_INC_m;

	OP(0x34):	// INC	(HL)
		EA = zHL;

OP_INC_m:
		READ_BYTE(EA, val)
		val = (val + 1) & 0xff;
		WRITE_BYTE(EA, val)
		zF = (zF & CF) | SZHV_inc[val];
		NEXT


/*-----------------------------------------
 DEC r8
-----------------------------------------*/

	OP(0x05):	// DEC	B
	OP(0x0d):	// DEC	C
	OP(0x15):	// DEC	D
	OP(0x1d):	// DEC	E
	OP(0x25):	// DEC	H
	OP(0x2d):	// DEC	L
	OP(0x3d):	// DEC	A
OP_DEC_R:
		zR8(Opcode >> 3)--;
		zF = (zF & CF) | SZHV_dec[zR8(Opcode >> 3)];
		NEXT

OP_DEC_mIx:
		EA = data->W + FETCH_BYTE_S;
		goto OP_DEC_m;

	OP(0x35):	// DEC	(HL)
		EA = zHL;

OP_DEC_m:
		READ_BYTE(EA, val)
		val = (val - 1) & 0xff;
		WRITE_BYTE(EA, val)
		zF = (zF & CF) | SZHV_dec[val];
		NEXT


/*-----------------------------------------
 ADD r8
-----------------------------------------*/

OP_ADD_mIx:
		READ_BYTE(data->W + FETCH_BYTE_S, val)
		goto OP_ADD;

	OP(0xc6):	// ADD	A,n
OP_ADD_imm:
		val = FETCH_BYTE;
		goto OP_ADD;

	OP(0x86):	// ADD	A,(HL)
//OP_ADD_mHL:
		READ_BYTE(zHL, val)
		goto OP_ADD;

OP_ADD_IxH:
		val = data->B.H;
		goto OP_ADD;

OP_ADD_IxL:
		val = data->B.L;
		goto OP_ADD;

	OP(0x80):	// ADD	A,B
	OP(0x81):	// ADD	A,C
	OP(0x82):	// ADD	A,D
	OP(0x83):	// ADD	A,E
	OP(0x84):	// ADD	A,H
	OP(0x85):	// ADD	A,L
	OP(0x87):	// ADD	A,A
OP_ADD_R:
		val = zR8(Opcode & 7);

OP_ADD:
		ADD(val)
		NEXT


/*-----------------------------------------
 ADC r8
-----------------------------------------*/

OP_ADC_mIx:
		READ_BYTE(data->W + FETCH_BYTE_S, val)
		goto OP_ADC;

	OP(0xce):	// ADC	A,n
OP_ADC_imm:
		val = FETCH_BYTE;
		goto OP_ADC;

	OP(0x8e):	// ADC	A,(HL)
//OP_ADC_mHL:
		READ_BYTE(zHL, val)
		goto OP_ADC;

OP_ADC_IxH:
		val = data->B.H;
		goto OP_ADC;

OP_ADC_IxL:
		val = data->B.L;
		goto OP_ADC;

	OP(0x88):	// ADC	A,B
	OP(0x89):	// ADC	A,C
	OP(0x8a):	// ADC	A,D
	OP(0x8b):	// ADC	A,E
	OP(0x8c):	// ADC	A,H
	OP(0x8d):	// ADC	A,L
	OP(0x8f):	// ADC	A,A
OP_ADC_R:
		val = zR8(Opcode & 7);

OP_ADC:
		ADC(val)
		NEXT


/*-----------------------------------------
 SUB r8
-----------------------------------------*/

OP_SUB_mIx:
		READ_BYTE(data->W + FETCH_BYTE_S, val)
		goto OP_SUB;

	OP(0xd6):	// SUB	A,n
OP_SUB_imm:
		val = FETCH_BYTE;
		goto OP_SUB;

	OP(0x96):	// SUB	(HL)
//OP_SUB_mHL:
		READ_BYTE(zHL, val)
		goto OP_SUB;

OP_SUB_IxH:
		val = data->B.H;
		goto OP_SUB;

OP_SUB_IxL:
		val = data->B.L;
		goto OP_SUB;

	OP(0x90):	// SUB	B
	OP(0x91):	// SUB	C
	OP(0x92):	// SUB	D
	OP(0x93):	// SUB	E
	OP(0x94):	// SUB	H
	OP(0x95):	// SUB	L
	OP(0x97):	// SUB	A
OP_SUB_R:
		val = zR8(Opcode & 7);

OP_SUB:
		SUB(val)
		NEXT


/*-----------------------------------------
 SBC r8
-----------------------------------------*/

OP_SBC_mIx:
		READ_BYTE(data->W + FETCH_BYTE_S, val)
		goto OP_SBC;

	OP(0xde):	// SBC	A,n
OP_SBC_imm:
		val = FETCH_BYTE;
		goto OP_SBC;

	OP(0x9e):	// SBC	A,(HL)
//OP_SBC_mHL:
		READ_BYTE(zHL, val)
		goto OP_SBC;

OP_SBC_IxH:
		val = data->B.H;
		goto OP_SBC;

OP_SBC_IxL:
		val = data->B.L;
		goto OP_SBC;

	OP(0x98):	// SBC	A,B
	OP(0x99):	// SBC	A,C
	OP(0x9a):	// SBC	A,D
	OP(0x9b):	// SBC	A,E
	OP(0x9c):	// SBC	A,H
	OP(0x9d):	// SBC	A,L
	OP(0x9f):	// SBC	A,A
OP_SBC_R:
		val = zR8(Opcode & 7);

OP_SBC:
		SBC(val)
		NEXT


/*-----------------------------------------
 CP r8
-----------------------------------------*/

OP_CP_mIx:
		READ_BYTE(data->W + FETCH_BYTE_S, val)
		goto OP_CP;

	OP(0xfe):	// CP	n
OP_CP_imm:
		val = FETCH_BYTE;
		goto OP_CP;

	OP(0xbe):	// CP	(HL)
//OP_CP_mHL:
		READ_BYTE(zHL, val)
		goto OP_CP;

OP_CP_IxH:
		val = data->B.H;
		goto OP_CP;

OP_CP_IxL:
		val = data->B.L;
		goto OP_CP;

	OP(0xb8):	// CP	B
	OP(0xb9):	// CP	C
	OP(0xba):	// CP	D
	OP(0xbb):	// CP	E
	OP(0xbc):	// CP	H
	OP(0xbd):	// CP	L
	OP(0xbf):	// CP	A
OP_CP_R:
		val = zR8(Opcode & 7);

OP_CP:
		CP(val)
		NEXT


/*-----------------------------------------
 AND r8
-----------------------------------------*/

	OP(0xa6):	// AND	(HL)
//OP_AND_mHL:
		READ_BYTE(zHL, val)
		goto OP_AND;

	OP(0xe6):	// AND	A,n
OP_AND_imm:
		val = FETCH_BYTE;
		goto OP_AND;

OP_AND_IxL:
		val = data->B.L;
		goto OP_AND;

OP_AND_IxH:
		val = data->B.H;
		goto OP_AND;

	OP(0xa0):	// AND	B
	OP(0xa1):	// AND	C
	OP(0xa2):	// AND	D
	OP(0xa3):	// AND	E
	OP(0xa4):	// AND	H
	OP(0xa5):	// AND	L
	OP(0xa7):	// AND	A
OP_AND_R:
		val = zR8(Opcode & 7);

OP_AND:
		AND(val)
		NEXT


/*-----------------------------------------
 XOR r8
-----------------------------------------*/

	OP(0xae):	// XOR	(HL)
//OP_XOR_mHL:
		READ_BYTE(zHL, val)
		goto OP_XOR;

	OP(0xee):	// XOR	A,n
OP_XOR_imm:
		val = FETCH_BYTE;
		goto OP_XOR;

OP_XOR_IxL:
		val = data->B.L;
		goto OP_XOR;

OP_XOR_IxH:
		val = data->B.H;
		goto OP_XOR;

	OP(0xa8):	// XOR	B
	OP(0xa9):	// XOR	C
	OP(0xaa):	// XOR	D
	OP(0xab):	// XOR	E
	OP(0xac):	// XOR	H
	OP(0xad):	// XOR	L
	OP(0xaf):	// XOR	A
OP_XOR_R:
		val = zR8(Opcode & 7);

OP_XOR:
		XOR(val)
		NEXT


/*-----------------------------------------
 OR r8
-----------------------------------------*/

	OP(0xb6):	// OR	(HL)
//OP_OR_mHL:
		READ_BYTE(zHL, val)
		goto OP_OR;

	OP(0xf6):	// OR	A,n
OP_OR_imm:
		val = FETCH_BYTE;
		goto OP_OR;

OP_OR_IxL:
		val = data->B.L;
		goto OP_OR;

OP_OR_IxH:
		val = data->B.H;
		goto OP_OR;

	OP(0xb0):	// OR	B
	OP(0xb1):	// OR	C
	OP(0xb2):	// OR	D
	OP(0xb3):	// OR	E
	OP(0xb4):	// OR	H
	OP(0xb5):	// OR	L
	OP(0xb7):	// OR	A
OP_OR_R:
		val = zR8(Opcode & 7);

OP_OR:
		OR(val)
		NEXT


/*-----------------------------------------
 MISC ARITHMETIC & cpu CONTROL
-----------------------------------------*/

	OP(0x27):	// DAA
OP_DAA:
		DAA
		NEXT

	OP(0x2f):	// CPL
OP_CPL:
		CPL
		NEXT

	OP(0x37):	// SCF
OP_SCF:
		SCF
		NEXT

	OP(0x3f):	// CCF
OP_CCF:
		CCF
		NEXT

	OP(0x76):	// HALT
OP_HALT:
		Z80.Halted = 1;
		Z80.ICount = 0;
		goto Cz80_Exec_Really_End;

	OP(0xf3):	// DI
OP_DI:
		zIFF1 = zIFF2 = 0;
		NEXT

	OP(0xfb):	// EI
OP_EI:
		EI
		goto Cz80_Exec;


/*-----------------------------------------
 INC r16
-----------------------------------------*/

	OP(0x03):	// INC	BC
OP_INC_BC:
		zBC++;
		NEXT

	OP(0x13):	// INC	DE
OP_INC_DE:
		zDE++;
		NEXT

	OP(0x23):	// INC	HL
OP_INC_xx:
		data->W++;
		NEXT

	OP(0x33):	// INC	SP
OP_INC_SP:
		zSP++;
		NEXT


/*-----------------------------------------
 DEC r16
-----------------------------------------*/

	OP(0x0b):	// DEC	BC
OP_DEC_BC:
		zBC--;
		NEXT

	OP(0x1b):	// DEC	DE
OP_DEC_DE:
		zDE--;
		NEXT

	OP(0x2b):	// DEC	HL
OP_DEC_xx:
		data->W--;
		NEXT

	OP(0x3b):	// DEC	SP
OP_DEC_SP:
		zSP--;
		NEXT


/*-----------------------------------------
 ADD r16
-----------------------------------------*/

	OP(0x39):	// ADD	xx,SP
OP_ADD16_xx_SP:
		val = zSP;
		goto OP_ADD16;

	OP(0x29):	// ADD	xx,xx
OP_ADD16_xx_xx:
		val = data->W;
		goto OP_ADD16;

	OP(0x09):	// ADD	xx,BC
OP_ADD16_xx_BC:
		val = zBC;
		goto OP_ADD16;

	OP(0x19):	// ADD	xx,DE
OP_ADD16_xx_DE:
		val = zDE;

OP_ADD16:
		ADD16(data->W, val)
		NEXT


/*-----------------------------------------
 ROTATE
-----------------------------------------*/

	OP(0x07):	// RLCA
OP_RLCA:
		RLCA
		NEXT

	OP(0x0f):	// RRCA
OP_RRCA:
		RRCA
		NEXT

	OP(0x17):	// RLA
OP_RLA:
		RLA
		NEXT

	OP(0x1f):	// RRA
OP_RRA:
		RRA
		NEXT


/*-----------------------------------------
 JP
-----------------------------------------*/

	OP(0xd2):	// JP	NC,nn
OP_JP_NC:
		if(!(zF & CF)) goto OP_JP;
		zPC += 2;
		NEXT

	OP(0xda):	// JP	C,nn
OP_JP_C:
		if(zF & CF) goto OP_JP;
		zPC += 2;
		NEXT

	OP(0xe2):	// JP	PO,nn
OP_JP_PO:
		if(!(zF & VF)) goto OP_JP;
		zPC += 2;
		NEXT

	OP(0xea):	// JP	PE,nn
OP_JP_PE:
		if(zF & VF) goto OP_JP;
		zPC += 2;
		NEXT

	OP(0xf2):	// JP	P,nn
OP_JP_P:
		if(!(zF & SF)) goto OP_JP;
		zPC += 2;
		NEXT

	OP(0xfa):	// JP	M,nn
OP_JP_M:
		if(zF & SF) goto OP_JP;
		zPC += 2;
		NEXT

	OP(0xca):	// JP	Z,nn
OP_JP_Z:
		if(zF & ZF) goto OP_JP;
		zPC += 2;
		NEXT

	OP(0xc2):	// JP	NZ,nn
OP_JP_NZ:
		if(!(zF & ZF)) goto OP_JP;
		zPC += 2;
		NEXT

	OP(0xc3):	// JP	nn
OP_JP:
		PC = GET_WORD;
		SET_PC(PC);
		NEXT

	OP(0xe9):	// JP	(xx)
OP_JP_xx:
		PC = data->W;
		SET_PC(PC);
		NEXT_EX


/*-----------------------------------------
 JR
-----------------------------------------*/

	OP(0x38):	// JR	C,n
OP_JR_C:
		if(zF & CF) goto OP_JR;
		zPC++;
		NEXT

	OP(0x30):	// JR	NC,n
OP_JR_NC:
		if(!(zF & CF)) goto OP_JR;
		zPC++;
		NEXT

	OP(0x28):	// JR	Z,n
OP_JR_Z:
		if(zF & ZF) goto OP_JR;
		zPC++;
		NEXT

	OP(0x20):	// JR	NZ,n
OP_JR_NZ:
		if(!(zF & ZF)) goto OP_JR;
		zPC++;
		NEXT

	OP(0x10):	// DJNZ n
OP_DJNZ:
		Z80.ICount--;
		if(--zB) goto OP_JR;
		zPC++;
		NEXT

	OP(0x18):	// JR	n
OP_JR:
		EA = FETCH_BYTE_S;
		zPC += EA;
		NEXT_EX


/*-----------------------------------------
 CALL
-----------------------------------------*/

	OP(0xd4):	// CALL NC,nn
OP_CALL_NC:
		if(!(zF & CF)) goto OP_CALL;
		zPC += 2;
		NEXT

	OP(0xdc):	// CALL C,nn
OP_CALL_C:
		if(zF & CF) goto OP_CALL;
		zPC += 2;
		NEXT

	OP(0xe4):	// CALL PO,nn
OP_CALL_PO:
		if(!(zF & VF)) goto OP_CALL;
		zPC += 2;
		NEXT

	OP(0xec):	// CALL PE,nn
OP_CALL_PE:
		if(zF & VF) goto OP_CALL;
		zPC += 2;
		NEXT

	OP(0xf4):	// CALL P,nn
OP_CALL_P:
		if(!(zF & SF)) goto OP_CALL;
		zPC += 2;
		NEXT

	OP(0xfc):	// CALL M,nn
OP_CALL_M:
		if(zF & SF) goto OP_CALL;
		zPC += 2;
		NEXT

	OP(0xcc):	// CALL Z,nn
OP_CALL_Z:
		if(zF & ZF) goto OP_CALL;
		zPC += 2;
		NEXT

	OP(0xc4):	// CALL NZ,nn
OP_CALL_NZ:
		if(!(zF & ZF)) goto OP_CALL;
		zPC += 2;
		NEXT

	OP(0xcd):	// CALL nn
OP_CALL:
	{
	UINT32 oldRPC;
		FETCH_WORD(PC);
		oldRPC = zRealPC;
		PUSH_16(oldRPC);

		SET_PC(PC);
		NEXT_EX
	}


/*-----------------------------------------
 RET
-----------------------------------------*/

	OP(0xd0):	// RET	NC
OP_RET_NC:
		if(!(zF & CF)) goto OP_RET;
		NEXT

	OP(0xd8):	// RET	C
OP_RET_C:
		if(zF & CF) goto OP_RET;
		NEXT

	OP(0xe0):	// RET	PO
OP_RET_PO:
		if(!(zF & VF)) goto OP_RET;
		NEXT

	OP(0xe8):	// RET	PE
OP_RET_PE:
		if(zF & VF) goto OP_RET;
		NEXT

	OP(0xf0):	// RET	P
OP_RET_P:
		if(!(zF & SF)) goto OP_RET;
		NEXT

	OP(0xf8):	// RET	M
OP_RET_M:
		if(zF & SF) goto OP_RET;
		NEXT

	OP(0xc0):	// RET	NZ
OP_RET_NZ:
		if(!(zF & ZF)) goto OP_RET;
		NEXT

	OP(0xc8):	// RET	Z
OP_RET_Z:
		if(zF & ZF) goto OP_RET;
		NEXT

	OP(0xc9):	// RET
OP_RET:
		POP_16(PC);
		SET_PC(PC);
		NEXT_EX


/*-----------------------------------------
 RST
-----------------------------------------*/

	OP(0xc7):	// RST	0
	OP(0xcf):	// RST	1
	OP(0xd7):	// RST	2
	OP(0xdf):	// RST	3
	OP(0xe7):	// RST	4
	OP(0xef):	// RST	5
	OP(0xf7):	// RST	6
	OP(0xff):	// RST	7
OP_RST:
		PC = zRealPC;
		PUSH_16(PC);
		PC = Opcode & 0x38;
		SET_PC(PC);
		NEXT


/*-----------------------------------------
 OUT
-----------------------------------------*/

	OP(0xd3):	// OUT	(n),A
OP_OUT_mN_A:
		EA = (zA << 8) | FETCH_BYTE;
		OUT(EA, zA)
		NEXT


/*-----------------------------------------
 IN
-----------------------------------------*/

	OP(0xdb):	// IN	A,(n)
OP_IN_A_mN:
		EA = (zA << 8) | FETCH_BYTE;
		IN(EA, zA)
		NEXT


/*-----------------------------------------
 PREFIX
-----------------------------------------*/

	OP(0xcb):	// CB prefix (BIT & SHIFT INSTRUCTIONS)
//CB_PREFIX:
		/*zR++;*/
		Opcode = FETCH_BYTE;
		cc = cc_cb;
		#include "inc_opCB.c"

	OP(0xed):	// ED prefix
ED_PREFIX:
		/*zR++;*/
		Opcode = FETCH_BYTE;
		cc = cc_ed;
		#include "inc_opED.c"

	OP(0xdd):	// DD prefix (IX)
DD_PREFIX:
		data = pzIX;
		goto XY_PREFIX;

	OP(0xfd):	// FD prefix (IY)
FD_PREFIX:
		data = pzIY;

XY_PREFIX:
		/*zR++;*/
		Opcode = FETCH_BYTE;
		cc = cc_xy;
		#include "inc_opXY.c"

#ifndef CZ80_USE_JUMPTABLE
}
#endif

///////
	}

//Cz80_Exec_End:
	if(Z80.afterEI)
	{
		Z80.ICount += Z80.ExtraCycles;
		Z80.ExtraCycles = 0;
		Z80.afterEI = 0;
		CHECK_INT
		goto Cz80_Exec;
	}

Cz80_Exec_Really_End:

	return Z80.InitialICount - Z80.ICount;
}

/////////////////////////////////

// prototype
/////////////

//UINT32 Cz80_Read_Dummy(UINT32 adr);
//void Cz80_Write_Dummy(UINT32 adr, UINT32 data);

int Cz80_Interrupt_Ack_Dummy(int param)
{
	// return vector
	return 0xff;
}


/****************************************************************************
 * Processor initialization
 ****************************************************************************/
extern unsigned char* z80_get_mem_ptr(void);
void z80_init(void)
//	Cz80_ Init
//	Cz80_Set_Fetch( 0x0000, 0xffff, (u32)neogeo_z80_memory);
//	Cz80_Set_ReadB( &z80_read_memory_8);
//	Cz80_Set_WriteB( &z80_write_memory_8);
//	Cz80_Set_INPort( &neogeo_z80_port_r);
//	Cz80_Set_OUTPort( &neogeo_z80_port_w);
//	Cz80_ Reset
//	//cpu_enable = 0;
{
	UINT32 i, p;
//	UINT32 j;

	//my_memset0(cpu, sizeof(Z80_Regs));
	my_memset0(&Z80, sizeof(Z80));

	// flags tables initialisation
	for (i = 0; i < 256; i++)
	{
		p = 0;
		if( i&0x01 ) p++;
		if( i&0x02 ) p++;
		if( i&0x04 ) p++;
		if( i&0x08 ) p++;
		if( i&0x10 ) p++;
		if( i&0x20 ) p++;
		if( i&0x40 ) p++;
		if( i&0x80 ) p++;
		SZ[i] = i ? i & SF : ZF;
		SZ[i] |= (i & (YF | XF));		/* undocumented flag bits 5+3 */
		SZ_BIT[i] = i ? i & SF : ZF | PF;
		SZ_BIT[i] |= (i & (YF | XF));	/* undocumented flag bits 5+3 */
		SZP[i] = SZ[i] | ((p & 1) ? 0 : PF);
		SZHV_inc[i] = SZ[i];
		if( i == 0x80 ) SZHV_inc[i] |= VF;
		if( (i & 0x0f) == 0x00 ) SZHV_inc[i] |= HF;
		SZHV_dec[i] = SZ[i] | NF;
		if( i == 0x7f ) SZHV_dec[i] |= VF;
		if( (i & 0x0f) == 0x0f ) SZHV_dec[i] |= HF;
	}

//	Cz80_Set_Fetch(cpu, 0x0000, 0xffff, (UINT32)NULL);
//	Cz80_Set_ReadB(cpu, Cz80_Read_Dummy);
//	Cz80_Set_WriteB(cpu, Cz80_Write_Dummy);

///	Z80.irq_callback = Cz80_Interrupt_Ack_Dummy;
///	Z80.RETI_Callback = NULL;

	zIX = zIY = 0xffff; /* IX and IY are FFFF after a reset! */
	zF = ZF;			/* Zero flag is set */

	pzR8[0] = &zB;
	pzR8[1] = &zC;
	pzR8[2] = &zD;
	pzR8[3] = &zE;
	pzR8[4] = &zH;
	pzR8[5] = &zL;
	pzR8[6] = &zF;	// sAA
	pzR8[7] = &zA;	// sAF

	pzR16[0] = pzBC;
	pzR16[1] = pzDE;
	pzR16[2] = pzHL;
	pzR16[3] = pzAF;

//quick base
		zBase		=z80_get_mem_ptr();
}


void z80_reset(void)//int param)
{
	//my_memset0(cpu, (UINT32)(&(Z80.ExtraCycles)) - (UINT32)(&(Z80.BC)));

//	Cz80_Set_PC(cpu, 0);
//	zPC =0;
	SET_PC(0);
//	//cpu_enable = 1;//param;
}

/////////////

void Cz80_Set_IRQ(void)
{
	Z80.IRQLine = 1;
	CHECK_INT
}

void Cz80_Set_NMI(void)
{
	zIFF1 = 0;
	Z80.ExtraCycles += 11;
	/*zR++;*/
	Z80.Halted = 0;

	PUSH_16(zPC - zBase)
//	Cz80_Set_PC(cpu, 0x66);
//	zPC =0x66;
	SET_PC(0x66);
}

void Cz80_Clear_IRQ(void)
{
	Z80.IRQLine = 0;
}

/////////////////////////////////

int Cz80_Get_CycleToDo(void)
{
	return Z80.InitialICount;
}

int Cz80_Get_CycleRemaining(void)
{
	return Z80.InitialICount - (Z80.ICount + Z80.ExtraCycles);
}

int Cz80_Get_CycleDone(void)
{
	return Z80.ICount + Z80.ExtraCycles;
}

void Cz80_Release_Cycle(void)
{
	Z80.InitialICount = 0;
	Z80.ICount = 0;
	Z80.ExtraCycles = 0;
}

void Cz80_Add_Cycle( int cycle)
{
	Z80.InitialICount += cycle;
}

// Read / Write dummy functions
////////////////////////////////

//UINT32 Cz80_Read_Dummy(UINT32 adr){	return 0;}
//void Cz80_Write_Dummy(UINT32 adr, UINT32 data){}




// Read / Write core functions
///////////////////////////////

UINT32 Cz80_Read_Byte( UINT32 adr)
{
	return /*Z80.Read_Byte*/z80_readmem16(adr);
}

UINT32 Cz80_Read_Word( UINT32 adr)
{
//#if CZ80_USE_WO RD_HANDLER
//	return Z80.Read_Word(adr);
//#elif CZ80_LIT TLE_ENDIAN
	return /*Z80.Read_Byte*/z80_readmem16(adr) | (/*Z80.Read_Byte*/z80_readmem16(adr + 1) << 8);
//#else
//	return (/*Z80.Read_Byte*/z80_readmem16(adr) << 8) | /*Z80.Read_Byte*/z80_readmem16(adr + 1);
//#endif
}

void Cz80_Write_Byte( UINT32 adr, UINT32 data)
{
	/*Z80.Write_Byte*/z80_writemem16(adr, data);
}

void Cz80_Write_Word( UINT32 adr, UINT32 data)
{
//#if CZ80_USE_WO RD_HANDLER
//	Z80.Write_Word(adr, data);
//#elif CZ80_LIT TLE_ENDIAN
	/*Z80.Write_Byte*/z80_writemem16(adr  , data & 0xff);
	/*Z80.Write_Byte*/z80_writemem16(adr+1, data >> 8);
//#else
//	/*Z80.Write_Byte*/z80_writemem16(adr, data >> 8);
//	/*Z80.Write_Byte*/z80_writemem16(adr + 1, data & 0xff);
//#endif
}

// setting core functions
//////////////////////////

//void Cz80_Set_Fetch(Z80_Regs *cpu, UINT32 low_adr, UINT32 high_adr, UINT32 fetch_adr)
//{
//	UINT32 i, j;
//	i = low_adr >> CZ80_FETCH_SFT;
//	j = high_adr >> CZ80_FETCH_SFT;
//	fetch_adr -= i << CZ80_FETCH_SFT;
//	while (i <= j) Z80.Fetch[i++] = (UINT8 *)fetch_adr;
//}

//void Cz80_Set_ReadB(Z80_Regs *cpu, UINT32 (*func)(UINT32 adr))
//{
//	Z80.Read_Byte = func;
//}
//void Cz80_Set_WriteB(Z80_Regs *cpu, void (*func)(UINT32 adr, UINT32 data))
//{
//	Z80.Write_Byte = func;
//}

//#if CZ80_USE_WO RD_HANDLER
//void Cz80_Set_ReadW(Z80_Regs *cpu, UINT32 (*func)(UINT32 adr))
//{
//	Z80.Read_Word = func;
//}
//void Cz80_Set_WriteW(Z80_Regs *cpu, void (*func)(UINT32 adr, UINT32 data))
//{
//	Z80.Write_Word = func;
//}
//#endif

//void Cz80_Set_INPort(Z80_Regs *cpu, UINT32 (*func)(UINT32 adr))
//{
//	Z80.IN_Port = func;
//}
//void Cz80_Set_OUTPort(Z80_Regs *cpu, void (*func)(UINT32 adr, UINT32 data))
//{
//	Z80.OUT_Port = func;
//}

//void Cz80_Set_IRQ_Callback( int (*callback)(int line))
//{
//	Z80.irq_callback = callback;
//}

//void Cz80_Set_RETI_Callback( void (*callback)(void))
//{
//	Z80.RETI_Callback = callback;
//}

// externals main functions
////////////////////////////

//UINT32 Cz80_Get_BC(Z80_Regs *cpu){	return zBC;}
//UINT32 Cz80_Get_DE(Z80_Regs *cpu){	return zDE;}
//UINT32 Cz80_Get_HL(Z80_Regs *cpu){	return zHL;}
//UINT32 Cz80_Get_AF(Z80_Regs *cpu){	return zAF;}
//UINT32 Cz80_Get_BC2(Z80_Regs *cpu){ return zBC2;}
//UINT32 Cz80_Get_DE2(Z80_Regs *cpu){ return zDE2;}
//UINT32 Cz80_Get_HL2(Z80_Regs *cpu){ return zHL2;}
//UINT32 Cz80_Get_AF2(Z80_Regs *cpu){ return zAF2;}
//UINT32 Cz80_Get_IX(Z80_Regs *cpu){	return zIX;}
//UINT32 Cz80_Get_IY(Z80_Regs *cpu){	return zIY;}
//UINT32 Cz80_Get_SP(Z80_Regs *cpu){	return zSP;}
//UINT32 Cz80_Get_PC(Z80_Regs *cpu)
//{
//	return zPC /*- zBase*/;
//}
//UINT32 Cz80_Get_R(Z80_Regs *cpu){	return zR;}
//UINT32 Cz80_Get_IFF(Z80_Regs *cpu)
//{
//	UINT32 value = 0;
//	if(zIFF1 & CZ80_IFF) value |= 1;
//	if(zIFF2 & CZ80_IFF) value |= 2;
//	return value;
//}
//UINT32 Cz80_Get_IM(Z80_Regs *cpu){	return zIM;}
//UINT32 Cz80_Get_I(Z80_Regs *cpu){	return zI;}
//void Cz80_Set_BC(Z80_Regs *cpu, UINT32 value){	zBC = value;}
//void Cz80_Set_DE(Z80_Regs *cpu, UINT32 value){	zDE = value;}
//void Cz80_Set_HL(Z80_Regs *cpu, UINT32 value){	zHL = value;}
//void Cz80_Set_AF(Z80_Regs *cpu, UINT32 val){	zAF = val;}
//void Cz80_Set_BC2(Z80_Regs *cpu, UINT32 value){ zBC2 = value;}
//void Cz80_Set_DE2(Z80_Regs *cpu, UINT32 value){ zDE2 = value;}
//void Cz80_Set_HL2(Z80_Regs *cpu, UINT32 value){ zHL2 = value;}
//void Cz80_Set_AF2(Z80_Regs *cpu, UINT32 val){	zAF2 = val;}
//void Cz80_Set_IX(Z80_Regs *cpu, UINT32 value){	zIX = value;}
//void Cz80_Set_IY(Z80_Regs *cpu, UINT32 value){	zIY = value;}
//void Cz80_Set_SP(Z80_Regs *cpu, UINT32 value){	zSP = value;}
//void Cz80_Set_PC(Z80_Regs *cpu, UINT32 val)
//{
//	/*zBase = (UINT32)Z80.Fetch[val >> CZ80_FETCH_SFT];*/
//	zPC = val /*+ zBase*/;
//}
//void Cz80_Set_R(Z80_Regs *cpu, UINT32 value)
//{
//	zR = value & 0xff;
//	zR2 = value & 0x80;
//}
//void Cz80_Set_IFF(Z80_Regs *cpu, UINT32 value)
//{
//	zIFF = 0;
//	if(value & 1) zIFF1 = CZ80_IFF;
//	if(value & 2) zIFF2 = CZ80_IFF;
//}
//void Cz80_Set_IM(Z80_Regs *cpu, UINT32 value)
//{
//	zIM = value & 3;
//}
//void Cz80_Set_I(Z80_Regs *cpu, UINT32 value)
//{
//	zI = value & 0xff;
//}
/////////////////


//static int cpu_enable;





//[
#define IRQ_LINE_NMI 0x66
INLINE void z80_assert_irq(int irqline)
{
	if(irqline == IRQ_LINE_NMI)
		Cz80_Set_NMI();
	else
		Cz80_Set_IRQ();
}


INLINE void z80_clear_irq(int irqline)
{
	Cz80_Clear_IRQ();
}


void z80_set_irq_line(int irqline, int state)
{
	switch (state)
	{
	case CLEAR_LINE:
		z80_clear_irq(irqline);
		return;

	default:
//	case ASSERT_LINE:
		z80_assert_irq(irqline);
		return;
	}
}
void z80_set_irq_line0_off(void)
{
	z80_clear_irq(0);
}
void z80_set_irq_line0_on(void)
{
	z80_assert_irq(0);
}


//void z80_enable(int enable)
//{
//	cpu_enable = enable;
//}


#if 00


//SAVE_STATE
void state_save_z80(u8 *state_buf)
{
	u8 *in = state_buf;
	u32 pc = Cz80_Get_PC();

	state_save_word(&CZ80.BC.W, 1);
	state_save_word(&CZ80.DE.W, 1);
	state_save_word(&CZ80.HL.W, 1);
	state_save_word(&CZ80.AF.W, 1);
	state_save_word(&CZ80.IX.W, 1);
	state_save_word(&CZ80.IY.W, 1);
	state_save_word(&CZ80.SP.W, 1);
	state_save_long(&pc, 1);
	state_save_word(&CZ80.BC2.W, 1);
	state_save_word(&CZ80.DE2.W, 1);
	state_save_word(&CZ80.HL2.W, 1);
	state_save_word(&CZ80.AF2.W, 1);
	state_save_word(&CZ80.R.W, 1);
	state_save_word(&CZ80.IFF.W, 1);
	state_save_byte(&CZ80.I, 1);
	state_save_byte(&CZ80.IM, 1);
	state_save_byte(&CZ80.IRQVector, 1);
	state_save_byte(&CZ80.IRQLine, 1);
	state_save_byte(&CZ80.NMIState, 1);
	state_save_byte(&CZ80.afterEI, 1);
	state_save_byte(&CZ80.Halted, 1);
	state_save_long(&CZ80.ICount, 1);
	state_save_long(&CZ80.InitialICount, 1);
	state_save_long(&CZ80.ExtraCycles, 1);
}
void state_load_z80(u8 *state_buf)
{
	u8 *out = state_buf;
	u32 pc;
	state_load_word(&CZ80.BC.W, 1);
	state_load_word(&CZ80.DE.W, 1);
	state_load_word(&CZ80.HL.W, 1);
	state_load_word(&CZ80.AF.W, 1);
	state_load_word(&CZ80.IX.W, 1);
	state_load_word(&CZ80.IY.W, 1);
	state_load_word(&CZ80.SP.W, 1);
	state_load_long(&pc, 1);
	state_load_word(&CZ80.BC2.W, 1);
	state_load_word(&CZ80.DE2.W, 1);
	state_load_word(&CZ80.HL2.W, 1);
	state_load_word(&CZ80.AF2.W, 1);
	state_load_word(&CZ80.R.W, 1);
	state_load_word(&CZ80.IFF.W, 1);
	state_load_byte(&CZ80.I, 1);
	state_load_byte(&CZ80.IM, 1);
	state_load_byte(&CZ80.IRQVector, 1);
	state_load_byte(&CZ80.IRQLine, 1);
	state_load_byte(&CZ80.NMIState, 1);
	state_load_byte(&CZ80.afterEI, 1);
	state_load_byte(&CZ80.Halted, 1);
	state_load_long(&CZ80.ICount, 1);
	state_load_long(&CZ80.InitialICount, 1);
	state_load_long(&CZ80.ExtraCycles, 1);

//	Cz80_Set_PC( pc);
//	zPC =pc;
	SET_PC(pc);
}

/*************************/
/* Publics Z80 functions */
/*************************/


//void Cz80_Set_Fetch(Z80_Regs *cpu, UINT32 low_adr, UINT32 high_adr, UINT32 fetch_adr);

//void Cz80_Set_ReadB(Z80_Regs *cpu, UINT32 (*func)(UINT32 adr));
//void Cz80_Set_WriteB(Z80_Regs *cpu, void (*func)(UINT32 adr, UINT32 data));
//#if CZ80_USE_WO RD_HANDLER
//void Cz80_Set_ReadW(Z80_Regs *cpu, UINT32 (*func)(UINT32 adr));
//void Cz80_Set_WriteW(Z80_Regs *cpu, void (*func)(UINT32 adr, UINT32 data));
//#endif

//void Cz80_Set_INPort(Z80_Regs *cpu, UINT32 (*func)(UINT32 port));
//void Cz80_Set_OUTPort(Z80_Regs *cpu, void (*func)(UINT32 port, UINT32 value));

//void Cz80_Set_IRQ_Callback(Z80_Regs *cpu, int (*callback)(int line));
//void Cz80_Set_RETI_Callback(Z80_Regs *cpu, void (*callback)(void));

//UINT32  Cz80_Read_Byte(Z80_Regs *cpu, UINT32 adr);
//UINT32  Cz80_Read_Word(Z80_Regs *cpu, UINT32 adr);
//void Cz80_Write_Byte(Z80_Regs *cpu, UINT32 adr, UINT32 data);
//void Cz80_Write_Word(Z80_Regs *cpu, UINT32 adr, UINT32 data);



//void Cz80_Set_IRQ(Z80_Regs *cpu);
//void Cz80_Set_NMI(Z80_Regs *cpu);
//void Cz80_Clear_IRQ(Z80_Regs *cpu);

//int  Cz80_Get_CycleToDo(Z80_Regs *cpu);
//int  Cz80_Get_CycleRemaining(Z80_Regs *cpu);
//int  Cz80_Get_CycleDone(Z80_Regs *cpu);
//void Cz80_Release_Cycle(Z80_Regs *cpu);
//void Cz80_Add_Cycle(Z80_Regs *cpu, int cycle);

//UINT32  Cz80_Get_BC(Z80_Regs *cpu);
//UINT32  Cz80_Get_DE(Z80_Regs *cpu);
//UINT32  Cz80_Get_HL(Z80_Regs *cpu);
//UINT32  Cz80_Get_AF(Z80_Regs *cpu);

//UINT32  Cz80_Get_BC2(Z80_Regs *cpu);
//UINT32  Cz80_Get_DE2(Z80_Regs *cpu);
//UINT32  Cz80_Get_HL2(Z80_Regs *cpu);
//UINT32  Cz80_Get_AF2(Z80_Regs *cpu);

//UINT32  Cz80_Get_IX(Z80_Regs *cpu);
//UINT32  Cz80_Get_IY(Z80_Regs *cpu);
//UINT32  Cz80_Get_SP(Z80_Regs *cpu);
//UINT32  Cz80_Get_PC(Z80_Regs *cpu);

//UINT32  Cz80_Get_R(Z80_Regs *cpu);
//UINT32  Cz80_Get_IFF(Z80_Regs *cpu);
//UINT32  Cz80_Get_IM(Z80_Regs *cpu);
//UINT32  Cz80_Get_I(Z80_Regs *cpu);

//void Cz80_Set_BC(Z80_Regs *cpu, UINT32 value);
//void Cz80_Set_DE(Z80_Regs *cpu, UINT32 value);
//void Cz80_Set_HL(Z80_Regs *cpu, UINT32 value);
//void Cz80_Set_AF(Z80_Regs *cpu, UINT32 value);

//void Cz80_Set_BC2(Z80_Regs *cpu, UINT32 value);
//void Cz80_Set_DE2(Z80_Regs *cpu, UINT32 value);
//void Cz80_Set_HL2(Z80_Regs *cpu, UINT32 value);
//void Cz80_Set_AF2(Z80_Regs *cpu, UINT32 value);

//void Cz80_Set_IX(Z80_Regs *cpu, UINT32 value);
//void Cz80_Set_IY(Z80_Regs *cpu, UINT32 value);
//void Cz80_Set_SP(Z80_Regs *cpu, UINT32 value);
//void Cz80_Set_PC(Z80_Regs *cpu, UINT32 value);

//void Cz80_Set_R(Z80_Regs *cpu, UINT32 value);
//void Cz80_Set_IFF(Z80_Regs *cpu, UINT32 value);
//void Cz80_Set_IM(Z80_Regs *cpu, UINT32 value);
//void Cz80_Set_I(Z80_Regs *cpu, UINT32 value);


#endif

